loadMetadata <- function(file){
metadata <- data.table::fread(file)
# check table content (minimum one row of data)
if (nrow(metadata) < 1) {
stop("The metadata file must contain at least one row of data.")
}
# check required columns
required_columns <- c("library_type", "sample", "read1", "read2", "index", "whitelist")
if (!all(required_columns %in% colnames(metadata))) {
stop("The metadata file must contain the following columns: ",
paste(required_columns, collapse = ", "))
}
# check accepted values in library_type
valid_libraries <- c("Gene Expression", "Chromatin Accessibility")
if (!all(metadata$library_type %in% valid_libraries)) {
stop('Invalid library_type. Must be "Gene Expression" or "Chromatin Accessibility".')
}
# check sample column for non-empty values
if (any(is.na(metadata$sample) | metadata$sample == "" | length(unique(metadata$sample)) != 1)) {
stop("The sample column contains empty or missing values.")
}
# check read1 column
if (!all(.is_valid_fastq(metadata$read1))) {
stop("The read1 column must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check read2 column if present
if (!all(is.na(metadata$read2) | metadata$read2 == "" | .is_valid_fastq(metadata$read2))) {
stop("The read2 column, if present, must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check index column
if (!all(.is_valid_fastq(metadata$index))) {
stop("The index column must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check whitelist column
if (!all(grepl("\\.txt\\.gz$", metadata$whitelist, ignore.case = TRUE))) {
stop("The whitelist column must contain paths to files with .txt.gz extensions.")
}
# return metadata if all checks pass
return(metadata)
}
loadMetadata <- function(file){
metadata <- data.table::fread(file)
# check table content (minimum one row of data)
if (nrow(metadata) < 1) {
stop("The metadata file must contain at least one row of data.")
}
# check required columns
required_columns <- c("library_type", "sample", "read1", "read2", "index", "whitelist")
if (!all(required_columns %in% colnames(metadata))) {
stop("The metadata file must contain the following columns: ",
paste(required_columns, collapse = ", "))
}
# check accepted values in library_type
valid_libraries <- c("Gene Expression", "Chromatin Accessibility")
if (!all(metadata$library_type %in% valid_libraries)) {
stop('Invalid library_type. Must be "Gene Expression" or "Chromatin Accessibility".')
}
# check sample column for non-empty values
if (any(is.na(metadata$sample) | metadata$sample == "" | length(unique(metadata$sample)) != 1)) {
stop("The sample column contains empty or missing values.")
}
# check read1 column
if (!all(.is_valid_fastq(metadata$read1))) {
stop("The read1 column must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check read2 column if present
if (!all(is.na(metadata$read2) | metadata$read2 == "" | .is_valid_fastq(metadata$read2))) {
stop("The read2 column, if present, must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check index column
if (!all(.is_valid_fastq(metadata$index))) {
stop("The index column must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check whitelist column
if (!all(grepl("\\.txt\\.gz$", metadata$whitelist, ignore.case = TRUE))) {
stop("The whitelist column must contain paths to files with .txt.gz extensions.")
}
# return metadata if all checks pass
return(metadata)
}
loadSingleEnd <- function(metadata, library_type = "Gene Expression", sample = NULL){
# load metadata
sample <- unique(metadata$sample)
files <- metadata$read1
# extract names and sequences of reads assigned to HXB2 genomes
reads_se <- lapply(files, .seq_info)
names(reads_se) <- files #basename(files)
# remove empty fastq files from the list
reads_se <- reads_se[!unlist(lapply(reads_se, is.null))]
# extract hiv+ identified reads
reads_table <- data.table::rbindlist(
lapply(names(reads_se), function(read1)
# extract fastq content
sapply(reads_se[read1], function(record){
data.frame(
file_se = read1,
read_name = record["read_name"],
seq = record["seq"],
quality = record["quality"])}
)))
data.table::setnames(reads_table, names(reads_table), c("file_se", "read_name", "seq", "quality"))
reads_table <- merge(reads_table, metadata[,.(library_type, sample, read1, index, whitelist)], by.x = "file_se", by.y = "read1", all.x = TRUE)
return(reads_table)
}
recoverBarcode <- function(reads_table, library_type = "Gene Expression"){
if (library_type == "Chromatin Accessibility"){
cat("ATAC barcode to GEX barcode")
} else{
cat("recovering GEX barcode + UMI")
# look for the barcode within the index file and append the barcode + UMI sequence in the table
reads_table[, barcode_umi := .gex_barcodes(read_name, index), by = read_name]
# barcode is located at the 16 starting nucleotides
reads_table[, barcode := substr(barcode_umi, 1, 16), by = read_name]
# UMI is located at the last 12 nucleotides
reads_table[, umi := substr(barcode_umi, 17, nchar(barcode_umi)), by = read_name]
}
return(reads_table)
}
.is_valid_fastq <- function(path) {
grepl("\\.fastq$|\\.fastq\\.gz$", path, ignore.case = TRUE)
}
.seq_info <- function(fastq){
if (!file.size(fastq) == 0L){
sr <- ShortRead::readFastq(fastq)
rseq <- sr@sread %>% as.data.frame()
rname <- data.table::tstrsplit(sr@id, " ")[[1]]
names(rseq) <- 'seq'
rseq$read_name <- rname
rquality <- as(quality(sr),"PhredQuality") %>% as.data.frame()
rseq$quality <- rquality$x
return(rseq)
}
}
.atac2gexbarcode <- function(barcode, atac_whitelist, gex_whitelist){
for(i in seq_along(atac_whitelist$V1)){
if (atac_whitelist$V1[i] == barcode){
gex_barcode <- gex_whitelist$V1[i] %>% as.character()
cat(barcode, " to ", gex_barcode)
}
}
return(gex_barcode)
}
.atac_barcodes <- function(read_name){
setkey(dt_index, 'read_name')
print(read_name)
fqfile <- dt_index[read_name, "index_path"] %>% as.character() # read FASTQ file w/ indexes
# Find target read in index file
barcode_dirty <- system(sprintf("LC_ALL=C zgrep -m1 -A1 %s %s | tail -1", read_name, fqfile),
intern= TRUE)
# atac barcode is located at the last 16 characters
read_len <- nchar(barcode_dirty)
barcode_clean <- substr(barcode_dirty, read_len-15, read_len)
barcode_revcomp <- Biostrings::DNAString(barcode_clean) %>%
Biostrings::reverseComplement() %>%
as.character() # Reverse complement
return(barcode_revcomp)
}
.gex_barcodes <- function(read_name, index_file){
# Find target read within the index file
barcode_dirty <- system(sprintf("LC_ALL=C zgrep -m1 -A1 %s %s | tail -1", read_name, index_file), intern= TRUE)
return(barcode_dirty) # this contain the barcode + umi sequences
# Barcodes are located at the 16 starting nucleotides
#barcode_clean <- substr(barcode_dirty, 1, 16)
#return(barcode_clean)
}
.hamming_distance <- function(barcode1, barcode2){
# check same length for barcode1 and barcode2
if (nchar(barcode1) != nchar(barcode2)) {
stop("Barcodes MUST have same length")
}
# compute Hamming distance (as the number of mismatching positions)
sum(strsplit(barcode1, NULL)[[1]] != strsplit(barcode2, NULL)[[1]])
}
print(.libPaths())
.libPaths("/imppc/external/irsicaixa/lgarrido/TOOLS/miniconda3/envs/r_env/bin/R")
print(.libPaths())
library(hivk2)
samples_list <- c(
'HIV1' = "/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV1_metadata.csv",
'HIV15' = "/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv",
'HIV16' = "/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV16_metadata.csv")
getwd()
samples_list
samples_list <- file.path("/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido", samples_list)
samples_list
md <- hivk2::loadMetadata("/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv")
md <- file.path("/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido", md)
print(md)
md <- hivk2::loadMetadata("/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv")
md <- loadMetadata("/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv")
library(data.table)
.libPaths()
library(datatable)
barcode1 <- "ATACCAGA"
barcode2 <- "ATAGCGGA"
.hamming_distance <- function(barcode1, barcode2){
if (nchar(barcode1) != nchar(barcode2)) {
return(min(nchar(barcode1), nchar()))
}
sum(strsplit(barcode1, "")[[1]] != strsplit(barcode2, "")[[1]] & barcode1 != "N" & barcode2 != "N")
}
.hamming_distance(barcode1, barcode2)
loadSingleEnd <- function(metadata, library_se = "Gene Expression", sample = NULL){
# load metadata
metadata <- metadata[library_type == library_se, ]
if (length(unique(metadata$sample)) == 0) {
sample <- if (!is.null(sample)) sample else stop("ERROR: wrong sample")
} else if (length(unique(metadata$sample)) == 1) {
sample <- unique(metadata$sample)
}
files_r1 <- if (!is.null(metadata$read1_path)) metadata$read1_path else stop("ERROR: missing R1 FASTQ file")
# extract names and sequences of reads assigned to HXB2 genomes
reads_se <- lapply(files_r1, .seq_info)
names(reads_se) <- files_r1 #basename(files_r1)
# remove empty fastq files from the list
reads_se <- reads_se[!unlist(lapply(reads_se, is.null))]
# extract hiv+ identified reads
reads_table <- data.table::rbindlist(
lapply(names(reads_se), function(sample_name)
# extract fastq content
sapply(reads_se[sample_name], function(record){
data.frame(
sample_file = sample_name,
read_name = record["read_name"],
seq = record["seq"],
quality = record["quality"])}
)))
data.table::setnames(reads_table, names(reads_table), c("sample_file", "read_name", "seq", "quality"))
reads_table <- merge(reads_table, metadata[,.(library_type, sample, read1_path, index_path, cellranger_output, whitelist)], by.x = "sample_file", by.y = "read1_path", all.x = TRUE)
return(reads_table)
}
library(data.table)
#library(magrittr)
library(tidyr)
library(ShortRead)
# load functions w/o package
wd <- getwd()
setwd("/home/lgarrido/Documentos/TASKs/hiv_kraken2/hivk2/R/")
setwd(wd); remove(wd)
samples_list <- c(
`HIV1` = "/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV1_metadata.csv",
`HIV15` = "/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv",
`HIV16` = "/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV16_metadata.csv")
id <- "HIV15"
outpath <- "/home/lgarrido/Documentos/TASKs/hiv_kraken2/test_data"
md <- loadMetadata("/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv")
loadMetadata <- function(file){
metadata <- data.table::fread(file)
# check table content (minimum one row of data)
if (nrow(metadata) < 1) {
stop("The metadata file must contain at least one row of data.")
}
# check required columns
required_columns <- c("library_type", "sample", "read1", "read2", "index", "whitelist")
if (!all(required_columns %in% colnames(metadata))) {
stop("The metadata file must contain the following columns: ",
paste(required_columns, collapse = ", "))
}
# set names
data.table::setnames(metadata, c("read1", "read2", "index"), c("read1_path", "read2_path", "index_path"))
# check accepted values in library_type
valid_libraries <- c("Gene Expression", "Chromatin Accessibility")
if (!all(metadata$library_type %in% valid_libraries)) {
stop('Invalid library_type. Must be "Gene Expression" or "Chromatin Accessibility".')
}
# check sample column for non-empty values
if (any(is.na(metadata$sample) | metadata$sample == "" | length(unique(metadata$sample)) != 1)) {
stop("The sample column contains empty or missing values.")
}
# check read1 column
if (!all(.is_valid_fastq(metadata$read1_path))) {
stop("The read1 column must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check read2 column if present
if (!all(is.na(metadata$read2_path) | metadata$read2_path == "" | .is_valid_fastq(metadata$read2_path))) {
stop("The read2 column, if present, must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check index column
if (!all(.is_valid_fastq(metadata$index_path))) {
stop("The index column must contain paths to files with .fastq or .fastq.gz extensions.")
}
# check whitelist column
if (!all(grepl("\\.txt\\.gz$", metadata$whitelist, ignore.case = TRUE))) {
stop("The whitelist column must contain paths to files with .txt.gz extensions.")
}
# return metadata if all checks pass
return(metadata)
}
md <- loadMetadata("/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv")
.is_valid_fastq <- function(path) {
grepl("\\.fastq$|\\.fastq\\.gz$", path, ignore.case = TRUE)
}
.seq_info <- function(fastq){
if (!file.size(fastq) == 0L){
sr <- ShortRead::readFastq(fastq)
rseq <- sr@sread %>% as.data.frame()
rname <- data.table::tstrsplit(sr@id, " ")[[1]]
names(rseq) <- 'seq'
rseq$read_name <- rname
rquality <- as(Biostrings::quality(sr), "PhredQuality") %>% as.data.frame()
rseq$quality <- rquality$x
return(rseq)
}
}
.atac_barcodes <- function(read_name, index_file){
# Find target read within the index file
# -A3 shows 3 lines after the match
# -m1 shows only the firs match
# detect number of available threads
nthreads <- parallel::detectCores()
#output <- system(sprintf("LC_ALL=C zgrep -A3 -m1 %s %s", read_name, index_file), intern=TRUE)
output <- system(sprintf("echo %s | parallel -j %d 'LC_ALL=C zgrep -A3 -m1 {} %s'",
read_name, nthreads, index_file), intern=TRUE)
# Extrae las líneas correctas del formato FASTQ
barcode_atac <- output[2]  # second line: nucleotide sequences (barcode + UMI)
quality_seq <- output[4]  # forth line: sequencing quality
# Extract atac barcode
# atac barcode is located at the last 16 characters
index_length <- nchar(barcode_atac)
barcode_atac <- substr(barcode_atac, index_length-15, index_length)
barcode_atac_revcomp <- Biostrings::DNAString(barcode_atac) %>%
Biostrings::reverseComplement() %>%
as.character() # Reverse complement
# Extract atac barcode's quality
quality_seq <- substr(quality_seq, index_length-15, index_length)
quality_seq_rev <- paste0(rev(strsplit(quality_seq, NULL)[[1]]), collapse = "") # reverse the quality
return(list(barcode_atac = barcode_atac_revcomp, barcode_atac_quality = quality_seq_rev))
}
.gex_barcodes <- function(read_name, index_file){
# Find target read within the index file
# -A3 shows 3 lines after the match
# -m1 shows only the firs match
# detect number of available threads
nthreads <- parallel::detectCores()
#output <- system(sprintf("LC_ALL=C zgrep -A3 -m1 %s %s", read_name, index_file), intern=TRUE)
output <- system(sprintf("echo %s | parallel -j %d 'LC_ALL=C zgrep -A3 -m1 {} %s'",
read_name, nthreads, index_file), intern=TRUE)
# Extrae las líneas correctas del formato FASTQ
barcode_umi <- output[2]  # second line: nucleotide sequences (barcode + UMI)
quality_seq <- output[4]  # forth line: sequencing quality
return(list(barcode_umi = barcode_umi, quality = quality_seq))
}
.hamming_distance <- function(barcode1, barcode2){
# check same length for barcode1 and barcode2
if (nchar(barcode1) != nchar(barcode2)) {
stop("Barcodes MUST have same length")
}
# compute Hamming distance (as the number of mismatching positions)
sum(strsplit(barcode1, NULL)[[1]] != strsplit(barcode2, NULL)[[1]])
}
.phred_to_prob <- function(q_score){
return(10^(-q_score / 10))
}
#  Función para convertir un carácter ASCII de calidad a número Phred
# @param quality_char quality symbol encoded as ASCII character
# @return Phred+33 encoding quality
.phred_ascii_to_num <- function(quality_char) {
return(utf8ToInt(quality_char) - 33)  # Phred+33 encoding
}
summary_counts <- function(res, library_type = NULL){
# process gex output
if (library_type == "Gene Expression"){
gex_umi_count <- res[,.N, by = .(sample, barcode, umi)]
summary_count <- gex_umi_count[,.N, by = .(sample, barcode)]
# process atac output
} else if (library_type == "Chromatin Accessibility"){
atac_read_count <- res[,.N, by = .(sample, barcode, read_pair)]
if ( nrow(atac_read_count[read_pair == "R1"]) != nrow(atac_read_count[read_pair == "R2"]) ){
stop("ERROR: discorcordant paired-end reads assignment (both reads of the pair must be assigned")
}
summary_count <- atac_read_count[,.N, by = .(sample, barcode)]
summary_count$N <- summary_count$N/2 # report paired-end reads
# no library indicated
} else {
stop("ERROR: missing library_type")
}
return(summary_count)
}
summary_cell_counts <- function(res, library_type = NULL){
# process gex and atac output
if (!is.null(library_type)){
res_counts <- summary_counts(res, library_type)
summary_count <- res_counts[,.N, by = .(sample)]
# no library indicated
} else {
stop("ERROR: missing library_type")
}
return(summary_count)
}
md <- loadMetadata("/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido/imppc/external/irsicaixa/lgarrido/TASKs/hiv_kraken2/test_data/HIV15_metadata.csv")
md
cols_to_modify <- c("read1_path", "read2_path", "index_path", "whitelist", "cellranger_output")
md[, (cols_to_modify) := lapply(.SD, function(x) gsub("/imppc/", "/run/user/1001/gvfs/sftp:host=172.19.7.53,user=lgarrido/imppc/", x)), .SDcols = cols_to_modify]
md
k2 <- loadSingleEnd(md,
library_se = "Gene Expression",
sample = id)
